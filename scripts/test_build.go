// main.go
// This program loads HL7 JSON definitions from a file,
// analyzes the JSON structure to generate corresponding Go struct definitions,
// and writes these definitions to a file (hl7_generated.go).
// Each generated field includes a struct tag with JSON and HL7 metadata
// (such as mandatory, length, table, and repeated).
// This base piece is intended for future expansion (e.g., for additional HL7 segments like PID and OBR).

package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// TableEntry represents an entry in an HL7 lookup table.
type TableEntry struct {
	Value       string `json:"value"`
	Description string `json:"description,omitempty"`
	Comment     string `json:"comment,omitempty"`
}

// Table is a slice of pointers to TableEntry objects.
type Table []*TableEntry

// DataTypePart defines a single component of a data type.
type DataTypePart struct {
	Mandatory  bool      `json:"mandatory,omitempty"`
	Name       string    `json:"name"`
	Repeats    bool      `json:"repeats,omitempty"`
	Type       string    `json:"type"`
	Length     int       `json:"length"`
	TableId    string    `json:"table,omitempty"`
	Composites *DataType `json:"composites,omitempty"`
}

// DataTypeVersion defines a version of a data type, including its parts.
type DataTypeVersion struct {
	AppliesTo string          `json:"appliesTo"`
	Length    int             `json:"length"`
	Parts     []*DataTypePart `json:"parts"`
}

// DataType defines the structure of an HL7 data type including its separator and versioning.
type DataType struct {
	Separator string                      `json:"separator"`
	Versions  map[string]*DataTypeVersion `json:"versions"`
}

// Definitions holds all HL7 table definitions and data type definitions.
type Definitions struct {
	Tables    map[string]*Table    `json:"tables,omitempty"`
	DataTypes map[string]*DataType `json:"dataTypes,omitempty"`
}

// GoStructField represents a field in a generated Go struct.
type GoStructField struct {
	FieldName string
	FieldType string
	TagProps  string // Holds metadata: mandatory, length, table, repeated, etc.
}

// GoStruct represents a generated Go struct definition.
type GoStruct struct {
	Name   string
	Fields []GoStructField
}

// GenerateGoStructs analyzes the JSON definitions and generates Go struct definitions.
// For each data type (using a preferred version “2.3.1” when available) it creates struct fields
// with a struct tag that includes both the JSON key and HL7 metadata.
func GenerateGoStructs(def *Definitions, outputPath string) error {
	// Prepare a slice to hold generated struct definitions.
	var structs []GoStruct

	for typeName, dataType := range def.DataTypes {
		var goStruct GoStruct
		goStruct.Name = typeName

		// Default version to "2.3.1" if available; otherwise, use the first available version.
		var version *DataTypeVersion
		if v, ok := dataType.Versions["2.3.1"]; ok {
			version = v
		} else {
			// Fallback: choose any available version.
			for _, v := range dataType.Versions {
				version = v
				break
			}
		}
		if version == nil {
			log.Printf("No version found for data type %s", typeName)
			continue
		}

		// Process each part of the selected version.
		for i, part := range version.Parts {
			var field GoStructField

			// Determine the field name: use part.Name if provided; otherwise a default name.
			if strings.TrimSpace(part.Name) == "" {
				field.FieldName = fmt.Sprintf("%sField%d", typeName, i+1)
			} else {
				field.FieldName = toCamelCase(part.Name)
			}

			baseType := part.Type
			// If the part type is "string", map it to Go's string; otherwise assume a defined type.
			if baseType == "string" {
				baseType = "string"
			}
			// If the part is repeating, use a slice.
			if part.Repeats {
				field.FieldType = "[]" + baseType
			} else {
				field.FieldType = baseType
			}

			// Build the HL7 metadata tag.
			var tags []string
			if part.Mandatory {
				tags = append(tags, "mandatory")
			}
			if part.Length >= 0 {
				tags = append(tags, fmt.Sprintf("length:%d", part.Length))
			}
			if part.TableId != "" {
				// Check that the referenced table exists.
				if _, ok := def.Tables[part.TableId]; !ok {
					tags = append(tags, fmt.Sprintf("table:%s(not found)", part.TableId))
				} else {
					tags = append(tags, fmt.Sprintf("table:%s", part.TableId))
				}
			}
			if part.Repeats {
				tags = append(tags, "repeated")
			}
			field.TagProps = strings.Join(tags, ",")

			goStruct.Fields = append(goStruct.Fields, field)
		}
		structs = append(structs, goStruct)
	}

	// Define a template for the generated Go structs.
	// Each field will have a struct tag that includes the json key and an "hl7" key with metadata.
	const tmpl = `// Code generated by hl7 dynamic generator. DO NOT EDIT.
package hl7

{{ range . }}
// {{ .Name }} represents the HL7 data type definition.
type {{ .Name }} struct {
	{{- range .Fields }}
	{{ .FieldName }} {{ .FieldType }} ` + "`json:\"{{ .FieldName }}\" hl7:\"{{ .TagProps }}\"`" + `
	{{- end }}
}
{{ end }}
`
	// Create or overwrite the output file.
	f, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %v", err)
	}
	defer f.Close()

	// Parse and execute the template with our generated structs.
	t := template.Must(template.New("structs").Parse(tmpl))
	if err := t.Execute(f, structs); err != nil {
		return fmt.Errorf("failed to execute template: %v", err)
	}

	log.Printf("Generated Go structs written to %s\n", outputPath)
	return nil
}

// toCamelCase converts a string to CamelCase.
func toCamelCase(s string) string {
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || r == ' '
	})
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(string(part[0])) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

// LoadDefinitions reads the HL7 JSON file from the given path and unmarshals it into a Definitions object.
func LoadDefinitions(filePath string) (*Definitions, error) {
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("error loading file (%s): %v", filePath, err)
	}
	var def Definitions
	if err := json.Unmarshal(data, &def); err != nil {
		return nil, fmt.Errorf("error unmarshalling JSON: %v", err)
	}
	return &def, nil
}

// ValidateFieldValue checks whether a provided field value exists in the lookup table for the given table ID.
// It logs a warning if the table or value is not found, but returns true if found and false otherwise.
func ValidateFieldValue(def *Definitions, tableId string, value string) bool {
	table, ok := def.Tables[tableId]
	if !ok {
		log.Printf("Warning: Table with ID '%s' not found in definitions.", tableId)
		return false
	}
	for _, entry := range *table {
		if entry.Value == value {
			return true
		}
	}
	log.Printf("Warning: Value '%s' not found in table '%s'. Using default empty value.", value, tableId)
	return false
}

// main is the entry point of the program.
// It loads the HL7 JSON definitions, generates Go struct definitions from the JSON structure,
// writes them to a file, and performs a sample table value validation.
func main() {
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("Unable to determine current working directory: %v", err)
	}

	jsonFilePath := filepath.Join(cwd, "..", "hl7", "app", "hl7.json")

	// Load HL7 definitions from the JSON file.
	def, err := LoadDefinitions(jsonFilePath)
	if err != nil {
		log.Fatalf("Failed to load HL7 definitions: %v", err)
	}

	// Using the data directory for (hl7_generated.go).
	outputFilePath := filepath.Join(cwd, "..", "data", "hl7_generated.go")
	if err := GenerateGoStructs(def, outputFilePath); err != nil {
		log.Fatalf("Error generating Go structs: %v", err)
	}

	// Sample validation: Check if a test value exists in a sample table. Can be expanded if testing for other tables.
	testTableID := "0003"
	testValue := "A04"
	if ValidateFieldValue(def, testTableID, testValue) {
		fmt.Printf("Value '%s' found in table '%s'.\n", testValue, testTableID)
	} else {
		fmt.Printf("Value '%s' NOT found in table '%s'.\n", testValue, testTableID)
	}

	// Future expansion: Additional dynamic processing (e.g., handling additional HL7 segments) can be added here.
	// If hl7_generated.go is found, you can delete it and run the program again to regenerate it.
}
